<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Space Shooter - Integration Tests</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #001122;
            color: white;
            font-family: Arial, sans-serif;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }

        .test-result {
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 3px;
        }

        .test-pass {
            background: #004400;
            color: #00ff00;
        }

        .test-fail {
            background: #440000;
            color: #ff0000;
        }

        .test-info {
            background: #004444;
            color: #00ffff;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #0088ff;
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        #gameCanvas {
            border: 2px solid #00ffff;
            margin: 10px 0;
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .metric {
            background: rgba(0, 50, 100, 0.3);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
        }

        .metric-label {
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>

<body>
    <div class="test-container">
        <h1>Enhanced Space Shooter - Integration Tests</h1>

        <div class="test-section">
            <h2>Test Controls</h2>
            <button onclick="runAllTests()">Run All Tests</button>
            <button onclick="runGameFlowTest()">Test Game Flow</button>
            <button onclick="runThemeTest()">Test Theme System</button>
            <button onclick="runPowerUpTest()">Test Power-Up System</button>
            <button onclick="runPerformanceTest()">Test Performance</button>
            <button onclick="clearResults()">Clear Results</button>
        </div>

        <div class="test-section">
            <h2>Game Canvas</h2>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>

        <div class="test-section">
            <h2>Performance Metrics</h2>
            <div class="performance-metrics">
                <div class="metric">
                    <div class="metric-value" id="fps">--</div>
                    <div class="metric-label">FPS</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="frameTime">--</div>
                    <div class="metric-label">Frame Time (ms)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="objectCount">--</div>
                    <div class="metric-label">Game Objects</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memoryUsage">--</div>
                    <div class="metric-label">Memory (MB)</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>Test Results</h2>
            <div id="testResults"></div>
        </div>
    </div>

    <script src="game.js"></script>
    <script>
        // Integration Test Suite
        class IntegrationTestSuite {
            constructor() {
                this.results = [];
                this.gameStateManager = null;
                this.performanceMetrics = {
                    frameCount: 0,
                    totalFrameTime: 0,
                    maxFrameTime: 0,
                    startTime: Date.now(),
                    objectCounts: []
                };
                this.testCanvas = document.getElementById('gameCanvas');
                this.testTimeout = null;
                this.currentTest = null;
                this.testStartTime = 0;
            }

            // Core test framework methods
            addResult(testName, passed, message, details = null) {
                const result = {
                    testName,
                    passed,
                    message,
                    details,
                    timestamp: new Date().toISOString()
                };
                this.results.push(result);
                this.displayResult(result);
            }

            displayResult(result) {
                const resultsDiv = document.getElementById('testResults');
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;

                let content = `[${result.testName}] ${result.message}`;
                if (result.details) {
                    content += ` (${result.details})`;
                }

                resultDiv.textContent = content;
                resultsDiv.appendChild(resultDiv);
                resultsDiv.scrollTop = resultsDiv.scrollHeight;
            }

            clearResults() {
                this.results = [];
                document.getElementById('testResults').innerHTML = '';
                this.resetPerformanceMetrics();
            }

            resetPerformanceMetrics() {
                this.performanceMetrics = {
                    frameCount: 0,
                    totalFrameTime: 0,
                    maxFrameTime: 0,
                    startTime: Date.now(),
                    objectCounts: []
                };
                this.updatePerformanceDisplay();
            }

            updatePerformanceDisplay() {
                const fps = this.performanceMetrics.frameCount > 0 ?
                    (1000 / (this.performanceMetrics.totalFrameTime / this.performanceMetrics.frameCount)) : 0;
                const avgFrameTime = this.performanceMetrics.frameCount > 0 ?
                    (this.performanceMetrics.totalFrameTime / this.performanceMetrics.frameCount) : 0;
                const avgObjectCount = this.performanceMetrics.objectCounts.length > 0 ?
                    (this.performanceMetrics.objectCounts.reduce((a, b) => a + b, 0) / this.performanceMetrics.objectCounts.length) : 0;

                document.getElementById('fps').textContent = fps.toFixed(1);
                document.getElementById('frameTime').textContent = avgFrameTime.toFixed(2);
                document.getElementById('objectCount').textContent = Math.round(avgObjectCount);

                // Memory usage (approximate)
                if (performance.memory) {
                    const memoryMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    document.getElementById('memoryUsage').textContent = memoryMB;
                } else {
                    document.getElementById('memoryUsage').textContent = 'N/A';
                }
            }

            // Initialize game state manager for testing
            initializeGameForTesting() {
                try {
                    // Clean up any existing game state manager
                    if (this.gameStateManager) {
                        this.gameStateManager = null;
                    }

                    // Create new game state manager
                    this.gameStateManager = new GameStateManager();

                    // Override the canvas to use our test canvas
                    this.gameStateManager.canvas = this.testCanvas;
                    this.gameStateManager.ctx = this.testCanvas.getContext('2d');

                    // Initialize game systems
                    if (this.gameStateManager.game) {
                        this.gameStateManager.game.canvas = this.testCanvas;
                        this.gameStateManager.game.ctx = this.gameStateManager.ctx;
                    }

                    return true;
                } catch (error) {
                    this.addResult('INIT', false, 'Failed to initialize game', error.message);
                    return false;
                }
            }

            // Wait for a specific condition with timeout
            async waitForCondition(conditionFn, timeout = 5000, checkInterval = 100) {
                const startTime = Date.now();

                return new Promise((resolve, reject) => {
                    const check = () => {
                        if (conditionFn()) {
                            resolve(true);
                        } else if (Date.now() - startTime > timeout) {
                            reject(new Error('Timeout waiting for condition'));
                        } else {
                            setTimeout(check, checkInterval);
                        }
                    };
                    check();
                });
            }

            // Simulate user input
            simulateKeyPress(keyCode, duration = 100) {
                return new Promise((resolve) => {
                    // Simulate keydown
                    const keydownEvent = new KeyboardEvent('keydown', { code: keyCode });
                    document.dispatchEvent(keydownEvent);

                    // Update keys state if game state manager exists
                    if (this.gameStateManager && this.gameStateManager.keys) {
                        this.gameStateManager.keys[keyCode] = true;
                    }

                    setTimeout(() => {
                        // Simulate keyup
                        const keyupEvent = new KeyboardEvent('keyup', { code: keyCode });
                        document.dispatchEvent(keyupEvent);

                        // Update keys state
                        if (this.gameStateManager && this.gameStateManager.keys) {
                            this.gameStateManager.keys[keyCode] = false;
                        }

                        resolve();
                    }, duration);
                });
            }

            simulateMouseClick(x, y) {
                const clickEvent = new MouseEvent('click', {
                    clientX: x + this.testCanvas.getBoundingClientRect().left,
                    clientY: y + this.testCanvas.getBoundingClientRect().top,
                    bubbles: true
                });
                this.testCanvas.dispatchEvent(clickEvent);
            }

            // Get current game object count for performance testing
            getGameObjectCount() {
                if (!this.gameStateManager || !this.gameStateManager.game) return 0;

                const game = this.gameStateManager.game;
                let count = 1; // Player

                if (game.bullets) count += game.bullets.length;
                if (game.enemies) count += game.enemies.length;
                if (game.particles) count += game.particles.length;
                if (game.powerUpSystem && game.powerUpSystem.powerUps) count += game.powerUpSystem.powerUps.length;

                return count;
            }

            // Performance monitoring
            startPerformanceMonitoring() {
                this.performanceMetrics.startTime = Date.now();
                this.performanceMetrics.frameCount = 0;
                this.performanceMetrics.totalFrameTime = 0;
                this.performanceMetrics.maxFrameTime = 0;
                this.performanceMetrics.objectCounts = [];

                const monitorFrame = () => {
                    if (this.currentTest) {
                        const frameStart = performance.now();

                        // Let the game render
                        setTimeout(() => {
                            const frameTime = performance.now() - frameStart;
                            this.performanceMetrics.frameCount++;
                            this.performanceMetrics.totalFrameTime += frameTime;
                            this.performanceMetrics.maxFrameTime = Math.max(this.performanceMetrics.maxFrameTime, frameTime);

                            // Track object count
                            const objectCount = this.getGameObjectCount();
                            this.performanceMetrics.objectCounts.push(objectCount);

                            // Update display every 30 frames
                            if (this.performanceMetrics.frameCount % 30 === 0) {
                                this.updatePerformanceDisplay();
                            }

                            requestAnimationFrame(monitorFrame);
                        }, 0);
                    }
                };

                requestAnimationFrame(monitorFrame);
            }

            // Test 1: Complete Game Flow Test
            async runGameFlowTest() {
                this.addResult('GAME_FLOW', true, 'Starting complete game flow test...', 'Testing intro → theme selection → gameplay → game over');
                this.currentTest = 'GAME_FLOW';
                this.startPerformanceMonitoring();

                try {
                    // Initialize game
                    if (!this.initializeGameForTesting()) {
                        throw new Error('Failed to initialize game');
                    }

                    // Test 1.1: Intro Screen
                    await this.testIntroScreen();

                    // Test 1.2: Theme Selection
                    await this.testThemeSelection();

                    // Test 1.3: Gameplay
                    await this.testGameplay();

                    // Test 1.4: Game Over
                    await this.testGameOver();

                    this.addResult('GAME_FLOW', true, 'Complete game flow test passed', 'All transitions working correctly');

                } catch (error) {
                    this.addResult('GAME_FLOW', false, 'Game flow test failed', error.message);
                } finally {
                    this.currentTest = null;
                }
            }

            async testIntroScreen() {
                // Verify intro screen is displayed
                await this.waitForCondition(() =>
                    this.gameStateManager && this.gameStateManager.currentState === GAME_STATES.INTRO
                );

                this.addResult('INTRO_SCREEN', true, 'Intro screen loaded successfully');

                // Test intro screen elements
                if (this.gameStateManager.introScreen) {
                    this.addResult('INTRO_ELEMENTS', true, 'Intro screen elements initialized');
                } else {
                    throw new Error('Intro screen not properly initialized');
                }

                // Simulate space key press to transition to theme selection
                await this.simulateKeyPress('Space', 200);

                // Wait for transition to theme selection
                await this.waitForCondition(() =>
                    this.gameStateManager.currentState === GAME_STATES.THEME_SELECT, 3000
                );

                this.addResult('INTRO_TRANSITION', true, 'Transition from intro to theme selection successful');
            }

            async testThemeSelection() {
                // Verify theme selection screen
                if (!this.gameStateManager.themeSelectScreen) {
                    throw new Error('Theme selection screen not initialized');
                }

                this.addResult('THEME_SCREEN', true, 'Theme selection screen loaded');

                // Test theme switching
                const originalTheme = this.gameStateManager.themeManager.getCurrentTheme().name;

                // Simulate arrow key to change theme
                await this.simulateKeyPress('ArrowRight', 200);
                await new Promise(resolve => setTimeout(resolve, 500));

                const newTheme = this.gameStateManager.themeManager.getCurrentTheme().name;
                if (newTheme !== originalTheme) {
                    this.addResult('THEME_SWITCH', true, `Theme switched from ${originalTheme} to ${newTheme}`);
                } else {
                    // Try different approach - simulate Enter to confirm current theme
                    await this.simulateKeyPress('Enter', 200);
                }

                // Wait for transition to gameplay
                await this.waitForCondition(() =>
                    this.gameStateManager.currentState === GAME_STATES.PLAYING, 3000
                );

                this.addResult('THEME_TRANSITION', true, 'Transition from theme selection to gameplay successful');
            }

            async testGameplay() {
                // Verify game is running
                if (!this.gameStateManager.game || !this.gameStateManager.game.gameRunning) {
                    throw new Error('Game not properly started');
                }

                this.addResult('GAMEPLAY_START', true, 'Gameplay started successfully');

                // Test player movement
                await this.testPlayerMovement();

                // Test shooting mechanics
                await this.testShooting();

                // Test enemy spawning
                await this.testEnemySpawning();

                // Test power-up system
                await this.testPowerUpCollection();

                // Force game over for testing
                this.gameStateManager.game.lives = 0;
                this.gameStateManager.game.gameRunning = false;

                // Wait for transition to game over
                await this.waitForCondition(() =>
                    this.gameStateManager.currentState === GAME_STATES.GAME_OVER, 3000
                );
            }

            async testPlayerMovement() {
                const game = this.gameStateManager.game;
                const initialX = game.player.x;
                const initialY = game.player.y;

                // Test right movement
                await this.simulateKeyPress('ArrowRight', 300);
                await new Promise(resolve => setTimeout(resolve, 100));

                if (game.player.x > initialX) {
                    this.addResult('PLAYER_MOVEMENT', true, 'Player movement (right) working');
                } else {
                    throw new Error('Player right movement not working');
                }

                // Test left movement
                await this.simulateKeyPress('ArrowLeft', 300);
                await new Promise(resolve => setTimeout(resolve, 100));

                if (game.player.x < initialX + 50) { // Should have moved back
                    this.addResult('PLAYER_MOVEMENT', true, 'Player movement (left) working');
                } else {
                    this.addResult('PLAYER_MOVEMENT', false, 'Player left movement not working properly');
                }
            }

            async testShooting() {
                const game = this.gameStateManager.game;
                const initialBulletCount = game.bullets.length;

                // Test shooting
                await this.simulateKeyPress('Space', 100);
                await new Promise(resolve => setTimeout(resolve, 200));

                if (game.bullets.length > initialBulletCount) {
                    this.addResult('SHOOTING', true, `Shooting working - ${game.bullets.length} bullets created`);
                } else {
                    throw new Error('Shooting not working - no bullets created');
                }
            }

            async testEnemySpawning() {
                const game = this.gameStateManager.game;

                // Force enemy spawn by setting last spawn time to 0
                game.lastEnemySpawn = 0;

                // Wait for enemy to spawn
                await new Promise(resolve => setTimeout(resolve, 1500));

                if (game.enemies.length > 0) {
                    this.addResult('ENEMY_SPAWN', true, `Enemy spawning working - ${game.enemies.length} enemies present`);
                } else {
                    this.addResult('ENEMY_SPAWN', false, 'Enemy spawning not working');
                }
            }

            async testPowerUpCollection() {
                const game = this.gameStateManager.game;

                // Force power-up spawn
                if (game.powerUpSystem) {
                    game.powerUpSystem.lastSpawn = 0;
                    game.powerUpSystem.spawnPowerUp(game.canvas.width);

                    if (game.powerUpSystem.powerUps.length > 0) {
                        this.addResult('POWERUP_SPAWN', true, 'Power-up spawning working');

                        // Move power-up to player position for collection test
                        const powerUp = game.powerUpSystem.powerUps[0];
                        powerUp.x = game.player.x;
                        powerUp.y = game.player.y;

                        // Wait for collection
                        await new Promise(resolve => setTimeout(resolve, 100));

                        if (game.powerUpSystem.activePowerUps.length > 0) {
                            this.addResult('POWERUP_COLLECTION', true, 'Power-up collection working');
                        } else {
                            this.addResult('POWERUP_COLLECTION', false, 'Power-up collection not working');
                        }
                    } else {
                        this.addResult('POWERUP_SPAWN', false, 'Power-up spawning not working');
                    }
                }
            }

            async testGameOver() {
                // Verify game over screen
                if (this.gameStateManager.currentState === GAME_STATES.GAME_OVER) {
                    this.addResult('GAME_OVER', true, 'Game over screen displayed correctly');
                } else {
                    throw new Error('Game over screen not displayed');
                }

                // Test restart functionality
                await this.simulateKeyPress('KeyR', 200);

                // Wait for transition back to gameplay
                await this.waitForCondition(() =>
                    this.gameStateManager.currentState === GAME_STATES.PLAYING, 3000
                );

                this.addResult('GAME_RESTART', true, 'Game restart functionality working');
            }

            // Test 2: Theme System Test
            async runThemeTest() {
                this.addResult('THEME_TEST', true, 'Starting theme system test...');
                this.currentTest = 'THEME_TEST';

                try {
                    if (!this.initializeGameForTesting()) {
                        throw new Error('Failed to initialize game');
                    }

                    const themeManager = this.gameStateManager.themeManager;
                    const availableThemes = ['MASKED_RIDER', 'ULTRAMAN', 'GODZILLA'];

                    // Test each theme
                    for (const themeName of availableThemes) {
                        const success = themeManager.loadTheme(themeName);
                        if (success) {
                            const currentTheme = themeManager.getCurrentTheme();
                            this.addResult('THEME_LOAD', true, `${themeName} theme loaded successfully`, currentTheme.name);

                            // Test theme components
                            const playerConfig = themeManager.getPlayerShipConfig();
                            const enemyConfig = themeManager.getEnemyShipConfig();
                            const bulletConfig = themeManager.getBulletConfig();

                            if (playerConfig && enemyConfig && bulletConfig) {
                                this.addResult('THEME_CONFIG', true, `${themeName} theme configurations valid`);
                            } else {
                                this.addResult('THEME_CONFIG', false, `${themeName} theme configurations invalid`);
                            }
                        } else {
                            this.addResult('THEME_LOAD', false, `Failed to load ${themeName} theme`);
                        }
                    }

                    // Test theme fallback
                    const fallbackSuccess = themeManager.loadTheme('INVALID_THEME');
                    if (!fallbackSuccess) {
                        this.addResult('THEME_FALLBACK', true, 'Theme fallback working correctly');
                    } else {
                        this.addResult('THEME_FALLBACK', false, 'Theme fallback not working');
                    }

                    this.addResult('THEME_TEST', true, 'Theme system test completed successfully');

                } catch (error) {
                    this.addResult('THEME_TEST', false, 'Theme system test failed', error.message);
                } finally {
                    this.currentTest = null;
                }
            }

            // Test 3: Power-Up System Test
            async runPowerUpTest() {
                this.addResult('POWERUP_TEST', true, 'Starting power-up system test...');
                this.currentTest = 'POWERUP_TEST';

                try {
                    if (!this.initializeGameForTesting()) {
                        throw new Error('Failed to initialize game');
                    }

                    // Navigate to gameplay
                    await this.simulateKeyPress('Space', 200);
                    await this.waitForCondition(() =>
                        this.gameStateManager.currentState === GAME_STATES.THEME_SELECT, 2000
                    );
                    await this.simulateKeyPress('Enter', 200);
                    await this.waitForCondition(() =>
                        this.gameStateManager.currentState === GAME_STATES.PLAYING, 2000
                    );

                    const game = this.gameStateManager.game;
                    const powerUpSystem = game.powerUpSystem;

                    // Test each power-up type
                    const powerUpTypes = Object.keys(POWER_UP_TYPES);

                    for (const powerUpType of powerUpTypes) {
                        await this.testSpecificPowerUp(powerUpType, game, powerUpSystem);
                    }

                    // Test multiple active power-ups
                    await this.testMultiplePowerUps(game, powerUpSystem);

                    this.addResult('POWERUP_TEST', true, 'Power-up system test completed successfully');

                } catch (error) {
                    this.addResult('POWERUP_TEST', false, 'Power-up system test failed', error.message);
                } finally {
                    this.currentTest = null;
                }
            }

            async testSpecificPowerUp(powerUpType, game, powerUpSystem) {
                // Create and collect power-up
                const powerUp = new PowerUp(game.player.x, game.player.y, powerUpType);
                powerUpSystem.collectPowerUp(powerUp, game);

                // Verify power-up is active
                const activePowerUps = powerUpSystem.getActivePowerUps();
                const isActive = activePowerUps.some(p => p.type === powerUpType);

                if (isActive) {
                    this.addResult('POWERUP_ACTIVATION', true, `${powerUpType} power-up activated successfully`);

                    // Test power-up effects
                    await this.testPowerUpEffects(powerUpType, game);

                    // Wait for power-up to expire or force expiration
                    const activePowerUp = activePowerUps.find(p => p.type === powerUpType);
                    if (activePowerUp) {
                        activePowerUp.timeRemaining = 0;
                        powerUpSystem.removePowerUpEffect(activePowerUp, game);
                        this.addResult('POWERUP_EXPIRATION', true, `${powerUpType} power-up expired correctly`);
                    }
                } else {
                    this.addResult('POWERUP_ACTIVATION', false, `${powerUpType} power-up not activated`);
                }
            }

            async testPowerUpEffects(powerUpType, game) {
                const player = game.player;

                switch (powerUpType) {
                    case 'RAPID_FIRE':
                        if (player.shootCooldown < 150) {
                            this.addResult('POWERUP_EFFECT', true, `${powerUpType} effect applied - cooldown reduced`);
                        } else {
                            this.addResult('POWERUP_EFFECT', false, `${powerUpType} effect not applied`);
                        }
                        break;

                    case 'WIDE_SHOT':
                        if (player.bulletSpread > 1) {
                            this.addResult('POWERUP_EFFECT', true, `${powerUpType} effect applied - spread increased`);
                        } else {
                            this.addResult('POWERUP_EFFECT', false, `${powerUpType} effect not applied`);
                        }
                        break;

                    case 'SHIELD_GENERATOR':
                        if (player.invincible) {
                            this.addResult('POWERUP_EFFECT', true, `${powerUpType} effect applied - invincibility active`);
                        } else {
                            this.addResult('POWERUP_EFFECT', false, `${powerUpType} effect not applied`);
                        }
                        break;

                    case 'TIME_SLOW':
                        if (game.timeScale < 1.0) {
                            this.addResult('POWERUP_EFFECT', true, `${powerUpType} effect applied - time scale reduced`);
                        } else {
                            this.addResult('POWERUP_EFFECT', false, `${powerUpType} effect not applied`);
                        }
                        break;

                    case 'MEGA_BLAST':
                        if (player.bulletPenetration && player.bulletDamage > 1) {
                            this.addResult('POWERUP_EFFECT', true, `${powerUpType} effect applied - penetration and damage increased`);
                        } else {
                            this.addResult('POWERUP_EFFECT', false, `${powerUpType} effect not applied`);
                        }
                        break;

                    case 'AUTO_AIM':
                        if (player.autoAim) {
                            this.addResult('POWERUP_EFFECT', true, `${powerUpType} effect applied - auto-aim active`);
                        } else {
                            this.addResult('POWERUP_EFFECT', false, `${powerUpType} effect not applied`);
                        }
                        break;

                    default:
                        this.addResult('POWERUP_EFFECT', false, `Unknown power-up type: ${powerUpType}`);
                }
            }

            async testMultiplePowerUps(game, powerUpSystem) {
                // Activate multiple power-ups simultaneously
                const powerUp1 = new PowerUp(game.player.x, game.player.y, 'RAPID_FIRE');
                const powerUp2 = new PowerUp(game.player.x, game.player.y, 'SHIELD_GENERATOR');

                powerUpSystem.collectPowerUp(powerUp1, game);
                powerUpSystem.collectPowerUp(powerUp2, game);

                const activePowerUps = powerUpSystem.getActivePowerUps();
                if (activePowerUps.length >= 2) {
                    this.addResult('MULTIPLE_POWERUPS', true, `Multiple power-ups active simultaneously (${activePowerUps.length})`);
                } else {
                    this.addResult('MULTIPLE_POWERUPS', false, 'Multiple power-ups not working correctly');
                }
            }

            // Test 4: Performance Test
            async runPerformanceTest() {
                this.addResult('PERFORMANCE_TEST', true, 'Starting performance test...');
                this.currentTest = 'PERFORMANCE_TEST';
                this.resetPerformanceMetrics();

                try {
                    if (!this.initializeGameForTesting()) {
                        throw new Error('Failed to initialize game');
                    }

                    // Navigate to gameplay
                    await this.simulateKeyPress('Space', 200);
                    await this.waitForCondition(() =>
                        this.gameStateManager.currentState === GAME_STATES.THEME_SELECT, 2000
                    );
                    await this.simulateKeyPress('Enter', 200);
                    await this.waitForCondition(() =>
                        this.gameStateManager.currentState === GAME_STATES.PLAYING, 2000
                    );

                    this.startPerformanceMonitoring();

                    // Create high-load scenario
                    await this.createHighLoadScenario();

                    // Monitor performance for 5 seconds
                    await new Promise(resolve => setTimeout(resolve, 5000));

                    // Analyze performance results
                    this.analyzePerformanceResults();

                } catch (error) {
                    this.addResult('PERFORMANCE_TEST', false, 'Performance test failed', error.message);
                } finally {
                    this.currentTest = null;
                }
            }

            async createHighLoadScenario() {
                const game = this.gameStateManager.game;

                // Spawn many enemies
                for (let i = 0; i < 20; i++) {
                    game.enemies.push(new Enemy(Math.random() * 700, Math.random() * 200, 'basic'));
                }

                // Spawn many bullets
                for (let i = 0; i < 50; i++) {
                    game.bullets.push(new Bullet(Math.random() * 800, Math.random() * 600, -5));
                }

                // Spawn many particles
                for (let i = 0; i < 100; i++) {
                    game.particles.push(new Particle(Math.random() * 800, Math.random() * 600));
                }

                // Spawn power-ups
                for (let i = 0; i < 10; i++) {
                    const powerUpTypes = Object.keys(POWER_UP_TYPES);
                    const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    game.powerUpSystem.powerUps.push(new PowerUp(Math.random() * 800, Math.random() * 600, randomType));
                }

                this.addResult('HIGH_LOAD', true, `High load scenario created - ${this.getGameObjectCount()} objects`);
            }

            analyzePerformanceResults() {
                const metrics = this.performanceMetrics;
                const avgFPS = metrics.frameCount > 0 ?
                    (1000 / (metrics.totalFrameTime / metrics.frameCount)) : 0;
                const avgFrameTime = metrics.frameCount > 0 ?
                    (metrics.totalFrameTime / metrics.frameCount) : 0;
                const maxObjectCount = Math.max(...metrics.objectCounts);

                // Performance thresholds
                const minAcceptableFPS = 30;
                const maxAcceptableFrameTime = 33.33; // ~30 FPS

                if (avgFPS >= minAcceptableFPS) {
                    this.addResult('PERFORMANCE_FPS', true, `Average FPS: ${avgFPS.toFixed(1)} (>= ${minAcceptableFPS})`);
                } else {
                    this.addResult('PERFORMANCE_FPS', false, `Average FPS: ${avgFPS.toFixed(1)} (< ${minAcceptableFPS})`);
                }

                if (avgFrameTime <= maxAcceptableFrameTime) {
                    this.addResult('PERFORMANCE_FRAME_TIME', true, `Average frame time: ${avgFrameTime.toFixed(2)}ms (<= ${maxAcceptableFrameTime}ms)`);
                } else {
                    this.addResult('PERFORMANCE_FRAME_TIME', false, `Average frame time: ${avgFrameTime.toFixed(2)}ms (> ${maxAcceptableFrameTime}ms)`);
                }

                this.addResult('PERFORMANCE_OBJECTS', true, `Max objects handled: ${maxObjectCount}`);

                // Memory usage check
                if (performance.memory) {
                    const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
                    if (memoryMB < 100) { // Less than 100MB
                        this.addResult('PERFORMANCE_MEMORY', true, `Memory usage: ${memoryMB.toFixed(1)}MB (< 100MB)`);
                    } else {
                        this.addResult('PERFORMANCE_MEMORY', false, `Memory usage: ${memoryMB.toFixed(1)}MB (>= 100MB)`);
                    }
                }

                this.addResult('PERFORMANCE_TEST', true, 'Performance test completed');
            }

            // Run all tests sequentially
            async runAllTests() {
                this.clearResults();
                this.addResult('ALL_TESTS', true, 'Starting comprehensive integration test suite...');

                try {
                    await this.runGameFlowTest();
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause between tests

                    await this.runThemeTest();
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    await this.runPowerUpTest();
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    await this.runPerformanceTest();

                    // Summary
                    const totalTests = this.results.length;
                    const passedTests = this.results.filter(r => r.passed).length;
                    const failedTests = totalTests - passedTests;

                    this.addResult('TEST_SUMMARY', true,
                        `All tests completed: ${passedTests}/${totalTests} passed, ${failedTests} failed`);

                } catch (error) {
                    this.addResult('ALL_TESTS', false, 'Test suite execution failed', error.message);
                }
            }
        }

        // Global test suite instance
        let testSuite = new IntegrationTestSuite();

        // Global test functions
        function runAllTests() {
            testSuite.runAllTests();
        }

        function runGameFlowTest() {
            testSuite.runGameFlowTest();
        }

        function runThemeTest() {
            testSuite.runThemeTest();
        }

        function runPowerUpTest() {
            testSuite.runPowerUpTest();
        }

        function runPerformanceTest() {
            testSuite.runPerformanceTest();
        }

        function clearResults() {
            testSuite.clearResults();
        }

        // Initialize test suite when page loads
        window.addEventListener('load', () => {
            testSuite.addResult('INIT', true, 'Integration test suite initialized and ready');
        });
    </script>
</body>

</html>